// Contains KernelStart and SetKernelBrk functions as defined in hardware.h
//
// Tamier Baoyin, Andrew Chen
// 1/2024

#include <ykernel.h>
#include <stdbool.h>
#include <stdio.h>

// indicates whether virtual memory has been enabled
// determines the behavior of SetKernelBrk()
bool is_vm_enabled = false;

int current_kernel_brk;

// trap handler function pointer type
typedef void (*TrapHandler)(UserContext uc);

// Process Control Block datastructure
struct pcb {
  UserContext uc;
  int pt_addr; // address of the corresponding page table
  int pid; // process id generated by helper_new_pid()
};

typedef struct pcb pcb_t;

void
KernelStart(char *cmd_args[], unsigned int pmem_size, UserContext *uctxt)
{
  // Initialize current_kernel_brk
  // Used to determine the frames occupied by kernel heap in SetKernelBrk()
  current_kernel_brk = _orig_kernel_brk_page << PAGESHIFT;

  // Set up a bit vector of size NUM_VPN to track free frames
  // This bit vector's initial values must be set before turning on VM
  // After VM is turned on, SetKernelBrk(), Brk syscall, and TRAP_MEMORY handler will be responsible for this vector
  int free_frames[] = malloc(NUM_VPN/8+1);
  
  // Set up the initial page tables
  // allocate memory for region 0 page table
  pte_t pt_0[] = malloc(sizeof(pte_t)*MAX_PT_LEN);
  // allocate memory for region 1 page table
  pte_t pt_1[] = malloc(sizeof(pte_t)*MAX_PT_LEN);
  // Set region 0 page table base
  WriteRegister(REG_PTBR0, &pt_0);
  // Set region 1 page table base
  WriteRegister(REG_PTBR1, &pt_1);
  // Set region 0 page table limit
  WriteRegister(REG_PTLR0, MAX_PT_LEN);
  // Set region 1 page table limit
  WriteRegister(REG_PTLR1, MAX_PT_LEN);

  // Initialize page table entries to map physical memory 1:1 with virtual memory
  // map kernel data, text, and heap: _first_kernel_data_page -> _first_kernel_text_page -> _orig_kernel_brk_page -> current_kernel_brk
  for (int page = _first_kernel_data_page; page < (UP_TO_PAGE(current_kernel_brk) & PAGEMASK); page++) {
    pte_t pte;
    pte.valid = 1;
    pte.prot = PROT_READ|PROT_WRITE;
    pte.pfn = page;
    pt_0[page] = pte;
  }

  // map kernel stack: KERNEL_STACK_BASE -> KERNEL_STACK_LIMIT
  for (int page = (KERNEL_STACK_BASE & PAGEMASK) ; page < (KERNEL_STACK_LIMIT & PAGEMASK); page++) {
    pte_t pte;
    pte.valid = 1;
    pte.prot = PROT_READ|PROT_WRITE;
    pte.pfn = page;
    pt_0[page] = pte;
  }

  // Set one page table entry to valid for user stack
  pte_t pte;
  pte.valid = 1;
  pte.prot = PROT_READ|PROT_WRITE;
  pte.pfn = MAX_VPN;
  pt_1[MAX_PT_LEN-1] = pte;

  // Enable Virtual Memory subsystem
  is_vm_enabled = true;
  WriteRegister(REG_VM_ENABLE, 1);

  // set up interrupt vector
  // Allocate array of function pointers of size TRAP_VECTOR_SIZE
  TrapHandler ivt[] = malloc(sizeof(TrapHandler)*TRAP_VECTOR_SIZE);

  // TODO: Write each entry of the array the pointer of the corresponding trap handler function

  WriteRegister(REG_VECTOR_BASE, &ivt);
  
  // Idle in user mode
  // Create idle pcb
  pcb_t idle_pcb;
  idle_pcb.uc = *uctxt;
  idle_pcb.pt_addr = &pt_1;
  // idle_pcb.pid = helper_new_pid();
}


int
SetKernelBrk(void * addr)
{
  // (we use -2*PAGESIZE to 2 pages between stack and heap, the “red zone”
  if (addr < KERNEL_STACK_BASE - 2*PAGESIZE) {
    if (is_vm_enabled) {
      // Allocate pages UP_TO_PAGE(Prev_brk) to UP_TO_PAGE(addr)
      current_kernel_brk = max(current_kernel_brk, addr+1);
    } else {
      current_kernel_brk = max(current_kernel_brk, addr+1);
    }
    return 0;
  } else {
    // error
  }
  
}

