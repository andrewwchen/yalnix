// Contains KernelStart and SetKernelBrk functions as defined in hardware.h
//
// Tamier Baoyin, Andrew Chen
// 1/2024

#include <ykernel.h>
#include <stdbool.h>
#include <stdio.h>
#include <traps.c>

// indicates whether virtual memory has been enabled
// determines the behavior of SetKernelBrk()
bool is_vm_enabled = false;

int current_kernel_brk;

int *allocated_frames;
pte_t *pt_0;
TrapHandler *ivt;

// trap handler function pointer type
typedef void (*TrapHandler)(UserContext uc);

// Process Control Block datastructure
struct pcb {
  UserContext uc;
  KernelContext kc;
  int kernel_stack_page_base; // TODO: what's the best way to store kernel stack?
  int kernel_stack_page_limit;
  int pt_addr; // address of the corresponding page table
  int pid; // process id generated by helper_new_pid()
  int *child_pids;
  int *parent_pids;
};

typedef struct pcb pcb_t;

void
KernelStart(char *cmd_args[], unsigned int pmem_size, UserContext *uctxt)
{
  // Initialize current_kernel_brk
  // Used to determine the frames occupied by kernel heap in SetKernelBrk()
  current_kernel_brk = _orig_kernel_brk_page << PAGESHIFT;

  // Set up a bit vector of size NUM_VPN to track allocated frames
  // This bit vector's initial values must be set before turning on VM
  // After VM is turned on, SetKernelBrk(), Brk syscall, and TRAP_MEMORY handler will be responsible for this vector
  allocated_frames = malloc(NUM_VPN/8+1);
  
  // Set up the initial page tables
  // allocate memory for region 0 page table
  pt_0 = malloc(sizeof(pte_t)*MAX_PT_LEN);
  // allocate memory for region 1 page table
  pte_t pt_1[] = malloc(sizeof(pte_t)*MAX_PT_LEN);
  // Set region 0 page table base
  WriteRegister(REG_PTBR0, &pt_0);
  // Set region 1 page table base
  WriteRegister(REG_PTBR1, &pt_1);
  // Set region 0 page table limit
  WriteRegister(REG_PTLR0, MAX_PT_LEN);
  // Set region 1 page table limit
  WriteRegister(REG_PTLR1, MAX_PT_LEN);

  // Initialize page table entries to map physical memory 1:1 with virtual memory
  // TODO: what goes first data or text
  // map kernel data, text, and heap: _first_kernel_data_page -> _first_kernel_text_page -> _orig_kernel_brk_page -> current_kernel_brk
  for (int page = _first_kernel_text_page; page < (UP_TO_PAGE(current_kernel_brk) & PAGEMASK); page++) {
    pte_t pte;
    pte.valid = 1;
    pte.prot = PROT_READ|PROT_WRITE;
    pte.pfn = page;
    pt_0[page] = pte;
    allocated_frames[page] = 1;
  }

  // map kernel stack: KERNEL_STACK_BASE -> KERNEL_STACK_LIMIT
  for (int page = (KERNEL_STACK_BASE & PAGEMASK) ; page < (KERNEL_STACK_LIMIT & PAGEMASK); page++) {
    pte_t pte;
    pte.valid = 1;
    pte.prot = PROT_READ|PROT_WRITE;
    pte.pfn = page;
    pt_0[page] = pte;
    allocated_frames[page] = 1;
  }

  // Set one page table entry to valid for user stack
  // TODO: ask whether MAX_VPN does in fact point to the top of the user stack
  pte_t pte;
  pte.valid = 1;
  pte.prot = PROT_READ|PROT_WRITE;
  pte.pfn = MAX_VPN;
  pt_1[MAX_VPN] = pte;
  allocated_frames[MAX_VPN] = 1;

  // Enable Virtual Memory subsystem
  is_vm_enabled = true;
  WriteRegister(REG_VM_ENABLE, 1);

  // set up interrupt vector
  // Allocate array of function pointers of size TRAP_VECTOR_SIZE
  // TODO: after VM is started, what should handle updating allocated_frames
  ivt = malloc(sizeof(TrapHandler)*TRAP_VECTOR_SIZE);
  ivt[TRAP_KERNEL] = &TrapKernel; // TODO
  ivt[TRAP_CLOCK] = &TrapClock; // TODO
  ivt[TRAP_ILLEGAL] = &TrapIllegal;
  ivt[TRAP_MEMORY] = &TrapMemory;
  ivt[TRAP_MATH] = &TrapMath;
  ivt[TRAP_TTY_RECEIVE] = &TrapTTYReceive;
  ivt[TRAP_TTY_TRANSMIT] = &TrapTTYTransmit;
  ivt[TRAP_DISK] = &TrapDisk;

  WriteRegister(REG_VECTOR_BASE, &ivt);// Allocate pages UP_TO_PAGE(Prev_brk) to UP_TO_PAGE(addr)
  
  // Idle in user mode
  // Create idle pcb
  pcb_t idle_pcb;
  idle_pcb.uc = *uctxt;
  idle_pcb.uc.pc = &DoIdle;
  idle_pcb.uc.sp = MAX_VPN;
  idle_pcb.kc = *kernel_context; // TODO: Where is kernel_context??
  idle_pcb.kernel_stack = segfseg; // TODO: what's the best way to store kernel stack
  idle_pcb.pt_addr = &pt_1;
  idle_pcb.pid = helper_new_pid(&pt_1);

  TracePrintf(1,"Leaving KernelStart\n");
}

void
DoIdle(void) {
  while(1) {
    TracePrintf(1,"DoIdle\n");
    Pause();
  }
}


int
SetKernelBrk(void * addr)
{
  // (we use -2*PAGESIZE to 2 pages between stack and heap, the “red zone”
  if (addr < KERNEL_STACK_BASE - 2*PAGESIZE) {
    if (is_vm_enabled) {
      if (addr+1 > current_kernel_brk) {
        for (int page = UP_TO_PAGE(current_kernel_brk); page < UP_TO_PAGE(addr); page++ ) { // TODO: verify that this is the right region to allocate
          allocated_frames[page] = 1;
        }
        current_kernel_brk = addr+1;
      } else {
        for (int page = UP_TO_PAGE(current_kernel_brk); page > UP_TO_PAGE(addr); page-- ) { // TODO: verify that this is the right region to allocate
          allocated_frames[page] = 0;
        }
        current_kernel_brk = addr+1;
      }
    } else {
      current_kernel_brk = max(current_kernel_brk, addr+1);
    }
    return 0;
  } else {
    return -1; // error
  }
}

