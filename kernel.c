// Contains KernelStart and SetKernelBrk functions as defined in hardware.h
//
// Tamier Baoyin, Andrew Chen
// 1/2024

#include <ykernel.h>
#include <stdbool.h>
#include <stdio.h>
#include <traps.c>
#include <queue.c>

// indicates whether virtual memory has been enabled
// determines the behavior of SetKernelBrk()
bool is_vm_enabled = false;

void *current_kernel_brk;

Queue_t* free_frames;
int *allocated_frames;
pte_t pt_0[MAX_PT_LEN];
void *ivt[TRAP_VECTOR_SIZE];
pcb_t idle_pcb;

// Process Control Block datastructure
struct pcb
{
  UserContext uc;
  KernelContext kc;
  pte_t kernel_stack_pages[KERNEL_STACK_MAXSIZE >> PAGESHIFT];
  void* pt_addr;  // address of the corresponding page table
  int pid;        // process id generated by helper_new_pid()
  int *child_pids;
  int *parent_pids;
};

typedef struct pcb pcb_t;

pte_t CreatePTE(int prot, int pfn) {
  pte_t pte;
  pte.valid = 1;
  pte.prot = prot;
  pte.pfn = pfn;
  return pte;
}

bool isInArray(int arr[], int n) {
  int length = sizeof(arr) / sizeof(int);
  for (int i=0; i<length; i++) {
    if (n == arr[i]) {
      return true;
    }
  }
  return false;
}

pcb_t CreateIdlePCB(UserContext *uc, void *pc) {
  // Create idle pcb
  // allocating memory, getting the kernel stack, creating a page table

  pte_t pt[] = malloc(sizeof(pte_t) * MAX_PT_LEN);

  pcb_t pcb;
  pcb.uc = *uc;
  pcb.uc.pc = pc;
  pcb.uc.sp = VMEM_1_LIMIT;

  int kernel_stack_frame_1 = deQueue(free_frames);
  int kernel_stack_frame_2 = deQueue(free_frames);
  allocated_frames[kernel_stack_frame_1] = 1;
  allocated_frames[kernel_stack_frame_2] = 1;
  pcb.kernel_stack_pages[0] = CreatePTE(PROT_READ | PROT_WRITE, kernel_stack_frame_1);
  pcb.kernel_stack_pages[1] = CreatePTE(PROT_READ | PROT_WRITE, kernel_stack_frame_2);

  pcb.pt_addr = &pt;
  pcb.pid = helper_new_pid(pt);

  // allocate frame TODO does this belong here
  int frame = deQueue(free_frames);
  allocated_frames[frame] = 1;
  pte_t pte = CreatePTE(PROT_READ | PROT_WRITE, frame);
  pt[MAX_PT_LEN-1] = pte;

  return pcb;
}

void DoIdle(void)
{
  while (1)
  {
    TracePrintf(1, "DoIdle\n");
    Pause();
  }
}

void KernelStart(char *cmd_args[], unsigned int pmem_size, UserContext *uctxt)
{
  // Initialize current_kernel_brk
  // Used to determine the frames occupied by kernel heap in SetKernelBrk()
  current_kernel_brk = _orig_kernel_brk_page << PAGESHIFT;

  // Set up a bit vector of size pmem_size / PAGESIZE) to track allocated frames
  // This bit vector's initial values must be set before turning on VM
  // After VM is turned on, SetKernelBrk(), Brk syscall, and TRAP_MEMORY handler will be responsible for this vector
  allocated_frames = malloc(pmem_size / PAGESIZE);

  // set up interrupt vector
  for (int trap_id = 0; trap_id < TRAP_VECTOR_SIZE; trap_id++)
  {
    ivt[trap_id] = TrapUnknown;
  }
  ivt[TRAP_KERNEL] = TrapKernel;
  ivt[TRAP_CLOCK] = TrapClock;
  ivt[TRAP_ILLEGAL] = TrapIllegal;
  ivt[TRAP_MEMORY] = TrapMemory;
  ivt[TRAP_MATH] = TrapMath;
  ivt[TRAP_TTY_RECEIVE] = TrapTTYReceive;
  ivt[TRAP_TTY_TRANSMIT] = TrapTTYTransmit;
  ivt[TRAP_DISK] = TrapDisk;

  WriteRegister(REG_VECTOR_BASE, (unsigned int) &ivt);

  // Set up region 0 page table
  bzero(&pt_0, MAX_PT_LEN); // TODO is this correct?
  WriteRegister(REG_PTBR0, (unsigned int) &pt_0);
  WriteRegister(REG_PTLR0, (unsigned int) &pt_0 + MAX_PT_LEN);

  // TODO: 6.3 helper_check_heap

  // Initialize page table entries to map physical memory 1:1 with virtual memory
  for (int page = _first_kernel_text_page; page < _first_kernel_data_page; page++)
  {
    pte_t pte = CreatePTE(PROT_READ | PROT_EXEC, page);
    pt_0[page] = pte;
    allocated_frames[page] = 1;
  }
  for (int page = _first_kernel_data_page; page < (UP_TO_PAGE(current_kernel_brk) & PAGEMASK); page++)
  {
    pte_t pte = CreatePTE(PROT_READ | PROT_WRITE, page);
    pt_0[page] = pte;
    allocated_frames[page] = 1;
  }

  for (int page = (KERNEL_STACK_BASE & PAGEMASK); page < (KERNEL_STACK_LIMIT & PAGEMASK); page++)
  {
    pte_t pte = CreatePTE(PROT_READ | PROT_WRITE, page);
    pt_0[page] = pte;
    allocated_frames[page] = 1;
  }

  // Enable Virtual Memory subsystem
  is_vm_enabled = true;
  WriteRegister(REG_VM_ENABLE, 1);
  WriteRegister(REG_TLB_FLUSH, 1);

  // Create free_frames queue
  free_frames = createQueue();
  for (int frame = 0; frame < pmem_size / PAGESIZE; frame++) {
    if (!isInArray(allocated_frames, frame)) {
      enQueue(free_frames, frame);
    }
  }

  // Idle in user mode
  // Create idle pcb
  idle_pcb = CreatePCB(uctxt, DoIdle);

  // call KernelContextSwitch with a new function MyKCS as argument to switch into the idle process from null and this handles the kc switch automatically
  KernelContextSwitch(KCSwitch, idle_pcb, NULL);

  TracePrintf(1, "Leaving KernelStart\n");
}

int SetKernelBrk(void *addr)
{
  if ((void *) addr > (void *) (KERNEL_STACK_BASE - (2 * PAGESIZE))) {
    return -1; // error
  } else if ((void *) addr < kernel_heap_start) { // TODO find where we can get this number
    return -1; // error
  } else if (!is_vm_enabled) {
    current_kernel_brk = (void *)((unsigned int)addr + 1);
  } else if (addr + 1 > current_kernel_brk) {
    int num_pages = UP_TO_PAGE(addr-current_kernel_brk) >> PAGESHIFT;
    int start_page = UP_TO_PAGE(current_kernel_brk) >> PAGESHIFT;
    for (int page = start_page; page < num_pages; page++)
    {
      int frame = deQueue(free_frames);
      allocated_frames[frame] = 1;
      pt_0[page] = CreatePTE(PROT_READ | PROT_WRITE, frame);
    }
  } else {
    int num_pages = DOWN_TO_PAGE(addr-current_kernel_brk) >> PAGESHIFT;
    int start_page = (unsigned int)current_kernel_brk >> PAGESHIFT;
    for (int page = start_page; page < num_pages; page--)
    {
      int frame = pt_0[page].pfn;
      enQueue(free_frames, frame);
      allocated_frames[frame] = 0;
      pt_0[page] = NULL; // TODO: double check how to empty a page table
    }
  }
  return 0;
}
